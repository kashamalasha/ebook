# Это задание охватывает весь изложенный выше материал. Вы когда-нибудь слышали про теорему о бесконечных обезьянах?
# В ней утверждается, что если обезьяна будет беспорядочно нажимать на клавиши клавиатуры бесконечное количество
# времени, то рано или поздно напечатает заданный текст (например, полное собрание сочинений Вильяма Шекспира).
# Что ж, предположим, что мы заменяем обезьяну функцией на Python. Как вы думаете, сколько она потратит времени
# на генерирование хотя бы одного предложения из Шекспира? Выберем для проверки фразу “methinks it is like a weasel”.
#
# Симуляция будет выполняться с помощью функции, генерирующей строку из двадцати семи символов путём случайного
# выбора из двадцати шести букв алфавита + пробел.
#
# Мы напишем ещё одну функцию, которая будет оценивать каждую сгенерированную строку, сравнивая её с целью.
#
# Третья функция будет циклично вызывать генератор и оценщик до тех пор, пока не совпадёт 100% букв.
# В случае несовпадения будет генерироваться новая строка целиком. Чтобы было проще следить за прогрессом программы,
# эта третья функция должна печатать лучшую из уже сгенерированных строк и её оценку каждые тысячу попыток.
#
# Усложнённое задание для самопроверки:
# Посмотрите, сможете ли вы улучшить программу из самопроверки, сохраняя правильно стоящие буквы и изменяя
# всего лишь одну из оставшихся, чтобы приблизиться к результату. Алгоритм такого типа относится к классу
# “поиска с восхождением к вершине”, в котором результат сохраняется только в том случае, если он лучше предыдущего.

import string
import random
import collections

ALPHABET = string.ascii_lowercase + ' '
AIM = 'methinks it is like a weasel'


def chargen():
    genstring = ''

    for x in range(len(AIM)):
        r = random.randrange(len(ALPHABET))
        genstring += ALPHABET[r]

    return genstring


def quality(a):
    correct = 0
    for x in range(len(AIM)):
        if a[x] == AIM[x]:
            correct += 1
    return correct


def run():
    count = 0
    done = False

    while not done:
        dic = dict()
        result = chargen()
        length = quality(result)
        dic[result] = length
        if length == len(AIM):
            print('%s : DONE' % result)
            done = True
        elif count == 1000:
            dic = collections.Counter(dic)
            dic = dic.most_common(1)
            print('%s : %d' % dic[0])
            count = 0
        else:
            count += 1

run()
